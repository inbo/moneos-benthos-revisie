---
bibliography: moneos.bib
---

# Resultaten

## Inschatting tonnage droge massa macrozo√∂benthos (totaal + foutenmarge)

```{r benthos-afdw}
benthos <- read_vc(file = "benthos",
                   root = find_root_file("data",
                                         criterion = is_git_root))

# correctie van ecotoop van een punt dat duidelijk in subtidaal lag
benthos$ecotoop_werkelijk[
  benthos$staal == "DU18_23" & benthos$jaar == "2018"] <- "matig diep subtidaal"

benthos_afdw <- benthos %>%
  mutate(survey = ifelse(grepl("raai", .$campagne.y), "raai", "spatial")) %>%
  # enkele stalen met negatieve AFDW: op nul zetten
  # bij enkele stalen stonden Z-waarden (hoogte) in mm ipv m
  mutate(AFDW = ifelse(AFDW < 0, 0, AFDW),
         Z = ifelse(Z >= 20, Z / 1000, Z)) %>%
  group_by(survey, campagne.x, campagne.y, staal, staalcode, jaar, datum.x,
           datum.y, real_X, real_Y, Z, geomorf, ecotoop_werkelijk,
           ecotoop_gepland, SalZone, Vallei_deel, Omessegment, KRWzone) %>%
  summarise(tot_aantal = sum(aantal),
            tot_afdw = sum(AFDW),
            aantal_fractietaxa = n_distinct(soort, fractie),
           .groups = "drop")
```

```{r eval=FALSE}
# mogelijke fouten in de data:
benthos_afdw %>%
  filter(str_extract(campagne.x, "SP\\d{2}") !=
           str_extract(campagne.y, "SP\\d{2}")) %>%
  select(staal, survey, campagne.x, campagne.y, jaar, datum.x, datum.y)
# verschillend jaartal in campagne.x en campagne.y
# variabele jaar komt overeen met campagne.y en is conform datum.x en datum.y
# dus best variabelen jaar en survey gebruiken (niet campagne.x)

# staal waar real_X 0 is en metadata ontbreken
benthos_afdw %>%
  filter(real_X == 0)
# uit mail Frank: DG18_23 is een bestaand benthosstaal (zie benthosdata -niet
# weggevallen of verlegd dus) in matig diep subtidaal genomen.
```

```{r ecotoop, warning=FALSE}
layers <- st_layers(gdrive_gdb_path)

ecotoop <- read_sf(gdrive_gdb_path,
                   layer = layers$name[1]) %>%
  st_cast("MULTIPOLYGON") %>%
  mutate(ecotoop_werkelijk = recode(as.factor(Ecotoop),
                                    "breuksteen" = "hard substraat",
                                    "hard antropogeen" = "hard substraat",
                                    "hoog slik" = "hoge slikzone",
                                    "middelhoog slik" = "middelhoge slikzone",
                                    "laag slik" = "lage slikzone",
                                    "intertidaal" = "slik"),
         KRWzone = recode(as.factor(KRWzone),
                          "TijarmZwijnaarde" = "Tijarm-Zwijnaarde"),
         KRWzone = replace_na(KRWzone, "Getijdedijle en -zenne")
         )
```

```{r benthos-ecotoop}
benthos_afdw_ecotoop <- benthos_afdw %>%
  st_as_sf(coords = c("real_X", "real_Y"), crs = 31370) %>%
  st_join(ecotoop %>%
            select(-KRWzone, -SalZone),
          left = FALSE,
          suffix = c(".benthos", ".ecotoop"))
```

```{r eval=FALSE}
# probleemgevallen met verschillende ecosysteem_werkelijk
benthos_afdw_ecotoop %>%
  filter(as.character(ecotoop_werkelijk.benthos) !=
           as.character(ecotoop_werkelijk.ecotoop)) %>%
  st_drop_geometry() %>%
  select(jaar, staal, starts_with("ecotoop_werkelijk")) %>%
  kable()
```

Enkel Zeeschelde, Rupel en Durme / geen raaien / enkel intertidaal

Berekening stratum weight = 1/inclusiekans

Inclusiekans = stratum_n \* opp_per_staal_m2 / stratum_opp_m2

```{r zeeschelde-durme}
benthos_afdw_ecotoop %>%
  select(jaar, survey, staal, staalcode, tot_afdw, tot_aantal,
         aantal_fractietaxa,
         ecotoop_werkelijk.benthos,
         KRWzone,
         SalZone,
         Vallei_deel,
         Naam,
         stratum_opp_m2 = Shape_Area,
         Z) %>%
  filter(Naam %in% c("Zeeschelde", "Durme")) %>%
  group_by(jaar, KRWzone, ecotoop_werkelijk.benthos) %>%
  mutate(
    tidaal = ifelse(str_detect(ecotoop_werkelijk.benthos, "subtidaal"),
                    "subtidaal", "intertidaal")) %>%
  arrange(jaar, KRWzone, ecotoop_werkelijk.benthos, staal) %>%
  ungroup() -> benthos_afdw_zeeschelde_durme
```

```{r benthos-afdw-spatial}
#diameter = 4.5 cm
opp_per_staal_m2 <- pi * (4.5 / 100) ^ 2 / 4

benthos_afdw_zeeschelde_durme %>%
  filter(survey == "spatial",
         tidaal != "subtidaal") %>%
  group_by(jaar, KRWzone, ecotoop_werkelijk.benthos) %>%
  mutate(stratum_n = n(),
         stratum_weight = stratum_opp_m2 / (opp_per_staal_m2 * stratum_n)
         ) %>%
  arrange(jaar, KRWzone, ecotoop_werkelijk.benthos, staal) %>%
  ungroup() -> benthos_afdw_spatial
```

(ref:spatial-steekproefgrootte) Gerealiseerde steekproefgroottes per stratumcombinatie op basis van enkel de spatial survey gegevens.

```{r spatial-steekproefgrootte}
benthos_afdw_spatial %>%
  st_drop_geometry() %>%
  distinct(jaar, ecotoop_werkelijk.benthos, KRWzone, SalZone, stratum_n) %>%
  kable(caption = "(ref:spatial-steekproefgrootte)")
```

Merk op dat de subtidale locaties niet nodig zijn voor de berekening waarbij een vergelijking nodig is met de streefwaarde van 30 ton biomassa.
Het gaat om iets minder dan de helft van het aantal locaties de spatial surveys (maar wellicht veel meer dan de helft in termen van tijd en kosten) (tabel \@ref(tab:spatial-steekproefgrootte-tidaal)).

(ref:spatial-steekproefgrootte-tidaal) Totaal aantal bezochte locaties in het subtidaal en het intertidaal in beide jaren.

```{r spatial-steekproefgrootte-tidaal}
benthos_afdw_zeeschelde_durme %>%
  filter(survey == "spatial") %>%
  st_drop_geometry() %>%
  count(jaar, tidaal) %>%
  kable(caption = "(ref:spatial-steekproefgrootte-tidaal)")
```

(ref:schattingen) Schatting van tonnages biomassa MZB in de intertidale zone van de Zeeschelde en Durme opgesplitst per jaar.

```{r schattingen}
# data.frame maken met alle survey design variabele en responsvariabelen
benthos_design <- benthos_afdw_spatial %>%
  as_survey_design(strata = c(KRWzone, ecotoop_werkelijk.benthos),
                   weights = stratum_weight)

# https://cran.r-project.org/web/packages/srvyr/vignettes/srvyr-vs-survey.html
# Horvitz-Thomson type schatters
benthos_design %>%
  group_by(jaar) %>%
  summarize(
    n = n(),
    mzb_tonnage = survey_total(
    x = tot_afdw / 1e6,
    na.rm = TRUE,
    vartype = "ci",
    level = 0.95)) %>%
  kable(digits = 1, caption = "(ref:schattingen)")
```

```{r svymle, eval=FALSE}
# ofwel droge stof via hurdle gamma distributie?
# cf examples in ?survey::svymle (voor censored lognormal)
# censored kan eventueel ook een optie zijn: alle nullen beschouwen als
# links-gecensureerde data met kleine cutoff
# zie ook ?survey::svysurvreg

# not working
# in terms of linear predictors (lp)
loglike_hurdle_gamma <- function(y, lp_shape, lp_rate, lp_hu) {
  hu <- plogis(lp_hu)
  shape <- exp(lp_shape)
  rate <- exp(lp_rate)
  ifelse(y == 0,
         dbinom(1, 1, hu, log = TRUE),
         dbinom(0, 1, hu, log = TRUE) +
           dgamma(y, shape = shape, rate = rate, log = TRUE)
  )
}

# derivatives with respect to hu, shape and rate

d_lp_shape <- function(y, lp_shape, lp_rate, lp_hu) {
  hu <- plogis(lp_hu)
  shape <- exp(lp_shape)
  rate <- exp(lp_rate)
  d_shape <- ifelse(
    y == 0,
    - (1 - y) / (1 - hu),
    y / hu +
      exp(-rate * y) * y^(shape - 1) * rate^shape / gamma(shape) *
      (log(rate) + log(y) - digamma(shape))
  )
  return(d_shape * shape)
}

d_lp_rate <- function(y, lp_shape, lp_rate, lp_hu) {
  hu <- plogis(lp_hu)
  shape <- exp(lp_shape)
  rate <- exp(lp_rate)
  d_rate <- ifelse(
    y == 0,
    - (1 - y) / (1 - hu),
    y / hu +
      y^(shape - 1) / gamma(shape) * exp(-rate * y) * rate^(shape - 1)
    * (shape - y * rate)
    )
  return(d_rate * rate)
}

d_lp_hu <- function(y, lp_shape, lp_rate, lp_hu) {
  hu <- plogis(lp_hu)
  d_hu <- y / hu - (1 - y) / (1 - hu)
  return(d_hu * (1 / hu + 1 / (1 - hu)) ^ (-1))
}

gradient_hurdle_gamma <- function(y, lp_shape, lp_rate, lp_hu) {
  return(
    cbind(
      d_lp_shape(y, lp_shape, lp_rate, lp_hu),
      d_lp_rate(y, lp_shape, lp_rate, lp_hu),
      d_lp_hu(y, lp_shape, lp_rate, lp_hu)
      )
    )
}

m <- svymle(
  loglike = loglike_hurdle_gamma,
  gradient = gradient_hurdle_gamma,
  design = benthos_design,
  method = "Nelder-Mead",
  formulas = list(~tot_afdw,
                  lp_shape = ~ 0 + jaar,
                  lp_rate = ~ 0 + jaar,
                  lp_hu = ~ 0 + jaar),
  start = list(c(0.5, 0),
               c(0.5, 0),
               c(0.1, 0)
  ),
  control = list(maxit = 10000),
  na.action = "na.omit"
)


summary(m)

# see also https://github.com/strengejacke/sjstats/blob/master/R/svyglmzip.R

# need predict method to obtain population total estimates, but no method for
# svymle


# from ?svymle The usual variance estimator for MLEs in a survey sample is a
# `sandwich' variance that requires the score vector and the information matrix.
# It requires only sampling assumptions to be valid (though some model
# assumptions are required for it to be useful).
# This is the stderr="robust" option, which is available only when the gradient
# argument was specified.
data.frame(est = coef(m), se = SE(m)) %>%
  rownames_to_column(var = "parameter") %>%
  separate(parameter, into = c("parameter", "jaar"), sep = ".jaar")

# combine with var-covar matrix to calculate CI on overall mean?
m$sandwich
all.equal(SE(m), sqrt(diag(m$sandwich)))
samples <- MASS::mvrnorm(n = 1e5, mu = coef(m), Sigma = m$sandwich)

mle_summary <- samples %>%
  as_tibble() %>%
  mutate(
    log_zero_part.2018 = log(1 - plogis(lp_hu.jaar2018)),
    log_gamma_part.2018 = log(exp(lp_shape.jaar2018) / exp(lp_rate.jaar2018)),
    sum_logparts.2018 = log_zero_part.2018 + log_gamma_part.2018,
    log_zero_part.2019 = log(1 - plogis(lp_hu.jaar2019)),
    log_gamma_part.2019 = log(exp(lp_shape.jaar2019) / exp(lp_rate.jaar2019)),
    sum_logparts.2019 = log_zero_part.2019 + log_gamma_part.2019
    ) %>%
  select(starts_with("sum")) %>%
  pivot_longer(cols = everything()) %>%
  separate(name, c("name", "jaar"), sep = "\\.") %>%
  group_by(jaar) %>%
  summarize(y = exp(median(value)) /
              opp_per_staal_m2,
            ymin = exp(quantile(value, 0.025)) /
              opp_per_staal_m2,
            ymax = exp(quantile(value, 0.975)) /
              opp_per_staal_m2,
            y_alternative = mean(exp(value) / opp_per_staal_m2))

# gram per m2
mle_summary

# vergelijk met:
benthos_design %>%
  group_by(jaar) %>%
  summarize(
    n = n(),
    mzb_gram_per_m2 = survey_mean(
    x = tot_afdw / opp_per_staal_m2,
    na.rm = TRUE,
    vartype = "ci",
    level = 0.95))
# er zit zeker nog iets fout
```

```{r replicate-weights, eval=FALSE}
# replicate weights?
benthos_design_repl <- as.svrepdesign(benthos_design)

hg_optim <- withReplicates(
  benthos_design_repl,
  quote(
    glmmTMB(tot_afdw / opp_per_staal_m2 ~ 0 + jaar,
            family = ziGamma(link = "log"),
            ziformula = ~ 0 + jaar,
            dispformula = ~ 0 + jaar,
            data = model.frame(benthos_design_repl),
            weights = .weights,
            se = TRUE,
            na.action = na.omit,
            control = glmmTMBControl(
              optimizer = optim,
              optArgs = list(method = "BFGS")
            ))$fit$par),
  return.replicates = TRUE
)

hg_optim %>%
  as_tibble() %>%
  mutate(param = rep(c("conditional", "hurdle", "dispersion"), each = 2),
         jaar = rep(c("2018", "2019"), times = 3)) %>%
  pivot_wider(id_cols = c(jaar),
              names_from = c(param),
              values_from = c(theta, SE)) %>%
  mutate(overall_mean = (1 - plogis(theta_hurdle)) * exp(theta_conditional))

hg_optim_sigma <- attr(hg_optim$theta, which = "var")
hg_optim_mean <- hg_optim$theta

hg_samples <- MASS::mvrnorm(n = 1e5, mu = hg_optim_mean, Sigma = hg_optim_sigma)
colnames(hg_samples) <- paste0(colnames(hg_samples), c(".2018", ".2019"))

hg_summary <- hg_samples %>%
  as_tibble() %>%
  mutate(
    log_zero_part.2018 = log(1 - plogis(betazi.2018)),
    log_gamma_part.2018 = beta.2018,
    sum_logparts.2018 = log_zero_part.2018 + log_gamma_part.2018,
    log_zero_part.2019 = log(1 - plogis(betazi.2019)),
    log_gamma_part.2019 = beta.2019,
    sum_logparts.2019 = log_zero_part.2019 + log_gamma_part.2019
    ) %>%
  select(starts_with("sum")) %>%
  pivot_longer(cols = everything()) %>%
  separate(name, c("name", "jaar"), sep = "\\.") %>%
  group_by(jaar) %>%
  summarize(y = exp(median(value)),
            ymin = exp(quantile(value, 0.025)),
            ymax = exp(quantile(value, 0.975)),
            y_alternative = mean(exp(value))
            )

hg_summary

# vergelijk met:
benthos_design %>%
  group_by(jaar) %>%
  summarize(
    n = n(),
    mzb_gram_per_m2 = survey_mean(
    x = tot_afdw / opp_per_staal_m2,
    na.rm = TRUE,
    vartype = "ci",
    level = 0.95))

# lijkt er al beter op
```

(ref:schattingen-subtargets) Schatting van tonnages biomassa MZB in de intertidale zone van de Zeeschelde en Durme opgesplitst per jaar en saliniteitszone.

```{r schattingen-subtargets}
# https://cran.r-project.org/web/packages/srvyr/vignettes/srvyr-vs-survey.html
# Horvitz-Thomson type schatters
benthos_design %>%
  group_by(jaar, SalZone) %>%
  summarize(
        n = n(),
        mzb_tonnage = survey_total(
          x = tot_afdw / 1e6,
          na.rm = TRUE,
          vartype = "ci",
          level = 0.95)) %>%
  kable(digits = 1, caption = "(ref:schattingen-subtargets)")


# ofwel droge stof via zero-inflated lognormal distributie?
# cf examples in ?survey::svymle (voor censored lognormal)
# censored kan eventueel ook een optie zijn: alle nullen beschouwen als
# links-gecensureerde data met kleine cutoff
# zie ook ?survey::svysurvreg
```

(ref:spatial-hoogtes) Voorstelling van de steekproef in functie van de hoogte en de verschillende saliniteitszones.

```{r spatial-hoogtes, fig.height=7.5, fig.cap="(ref:spatial-hoogtes)"}
benthos_afdw_spatial %>%
  mutate(staalcode = fct_reorder(staalcode, Z)) %>%
  ggplot() +
  geom_point(aes(x = Z, y = KRWzone, colour = jaar,
                 shape = ecotoop_werkelijk.benthos),
             position = position_dodge(width = 0.5)) +
  labs(x = "Hoogte (m)") +
  facet_grid(vars(SalZone), scales = "free_y")
```

Er lijkt een piek te zijn in de biomassa bij gemiddelde hoogte in het intertidaal.
Dit is zowel in de spatial survey als de raai-survey te zien (Figuur \@ref(fig:biomassa-hoogte)).
In principe kan dan de hoogtevariabele (die bij benadering overal gekend is via DTM beeld) gebruikt worden om de schattingen te verbeteren via design-based regressieschatters (**kan** leiden tot iets smallere betrouwbaarheidsintervallen).

(ref:biomassa-hoogte) Biomassa in functie van hoogteligging in het intertidaal voor beide survey-types.

```{r biomassa-hoogte, fig.cap="(ref:biomassa-hoogte)"}
benthos_afdw_zeeschelde_durme %>%
  filter(tidaal == "intertidaal") %>%
  ggplot(aes(x = Z, y = tot_afdw, colour = jaar)) +
  geom_point() +
  geom_smooth() +
  scale_y_sqrt() +
  facet_wrap(tidaal~survey, scales = "free") +
  labs(x = "Hoogte (m)",
       y = "Biomassa (g)")
```

```{r eval=FALSE}
benthos_afdw_zeeschelde_durme %>%
  filter(tidaal == "subtidaal",
         Z > 0) %>%
  st_drop_geometry() %>%
  select(jaar, staal, ecotoop_werkelijk.benthos, KRWzone, Z) %>%
  kable()
```

## Vergelijking raaien met gestratificeerde aselecte steekproef

In eerste stap veronderstellen we foutief dat de raaigegevens komen van een gestratificeerde aselecte steekproef.

```{r benthos-afdw-raai}
benthos_afdw_zeeschelde_durme %>%
  filter(survey == "raai",
         tidaal != "subtidaal") %>%
  group_by(jaar, KRWzone, ecotoop_werkelijk.benthos) %>%
  mutate(stratum_n = n(),
         stratum_weight = stratum_opp_m2 / (opp_per_staal_m2 * stratum_n)
         ) %>%
  arrange(jaar, KRWzone, ecotoop_werkelijk.benthos, staal) %>%
  ungroup() -> benthos_afdw_raai
```

(ref:raai-steekproefgrootte) Gerealiseerde steekproefgroottes per stratumcombinatie op basis van enkel de raaigegevens.

```{r raai-steekproefgrootte}
benthos_afdw_raai %>%
  st_drop_geometry() %>%
  distinct(jaar, ecotoop_werkelijk.benthos, KRWzone, SalZone, stratum_n) %>%
  kable(caption = "(ref:raai-steekproefgrootte)")
```

(ref:raai-steekproefgrootte-totaal) Totale jaarlijkse steekproefgrootte voor de raaien.

```{r raai-steekproefgrootte-totaal}
benthos_afdw_raai %>%
  st_drop_geometry() %>%
  count(jaar) %>%
  kable(caption = "(ref:raai-steekproefgrootte-totaal)")
```

(ref:schattingen-raai) Vertekende schattingen van de tonnages op basis van de raaigegevens en een foutieve veronderstelling dat de data onafhankelijke en aselect zijn.

```{r schattingen-raai}
# data.frame maken met alle survey design variabele en responsvariabelen
benthos_raai_design <- benthos_afdw_raai %>%
  as_survey_design(strata = c(KRWzone, ecotoop_werkelijk.benthos),
                   weights = stratum_weight)


benthos_raai_design %>%
  group_by(jaar) %>%
  summarise(
    n_raaien = n_distinct(staalcode),
    n = n(),
    mzb_tonnage = survey_total(
      x = tot_afdw / 1e6,
      na.rm = TRUE,
      vartype = "ci",
      level = 0.95)) %>%
  kable(digits = 1, caption = "(ref:schattingen-raai)")
```

(ref:schattingen-raai-subtargets) Vertekende schattingen per saliniteitszone van de tonnages op basis van de raaigegevens en een foutieve veronderstelling dat de data onafhankelijke en aselect zijn.

```{r schattingen-raai-subtargets}
benthos_raai_design %>%
  group_by(jaar, SalZone) %>%
  summarise(
    n_raaien = n_distinct(staalcode),
    n = n(),
        mzb_tonnage = survey_total(
          x = tot_afdw / 1e6,
          na.rm = TRUE,
          vartype = "ci",
          level = 0.95)) %>%
  kable(digits = 1, caption = "(ref:schattingen-raai-subtargets)")
```

Wellicht sterk vertekende schattingen (overschatting vermits vooral in beste gebieden).
Bovendien bekomen we bredere betrouwbaarheidsintervallen ondanks een hoger aantal locaties die via raaien bemonsterd worden in het intertidaal (150 versus 100-tal).

De voorgaande berekening was fout om minstens twee redenen: (1) we hielden geen rekening met de raaien, en (2) we gebruiken design-based inferentie terwijl het geen probabilistische steekproef betreft.

De ligging van de locaties langsheen de raaien is volgens een hoogtegradi√´nt (loodrecht op de as van de rivier).
Dit heeft tot voordeel dat er tussen de locaties veel variatie kan verwacht worden terwijl tegelijk het veldwerk beperkt blijft doordat de locaties dicht bij elkaar liggen.
Dit soort van samplingstrategie wordt bediscussieerd in @gillison1985.
De auteurs geven aan dat deze strategie, waarbij transecten gericht volgens een omgevingsgradi√´nt worden gekozen, aanvaardbaar kan zijn op voorwaarde dat de totale steekproef aantoonbaar representatief is voor de gehele doelpopulatie √©n wanneer het doel van de survey is om zoveel mogelijk diversiteit (niet biomassa!) te vatten in de steekproef.
In figuur \@ref(fig:raai-hoogtes) zien we duidelijk dat de locaties langsheen de raaien liggen volgens een hoogtegradi√´nt.
Tussen de jaren blijven deze hoogtes meestal gelijk, maar soms zien we grote verschillen wellicht door de rivierwerking of effecten van baggerwerken.

(ref:raai-hoogtes) De hoogteligging van bemonsterde locaties langs elk van de raaien. De lijnen verbinden dezelfde locaties bemonsterd in verschillend jaren.

```{r raai-hoogtes, fig.height=7.5, fig.cap="(ref:raai-hoogtes)"}
benthos_afdw_raai %>%
  mutate(staalcode = fct_reorder(staalcode, Z)) %>%
  ggplot() +
  geom_point(aes(x = Z, y = staalcode, colour = jaar,
                 shape = ecotoop_werkelijk.benthos)) +
  geom_line(aes(x = Z, y = staalcode, group = staal)) +
  labs(x = "Hoogte (m)") +
  facet_grid(vars(SalZone), scales = "free_y")
```

(ref:leaflet-map) Ligging van de raai-locaties en de locaties van de gestratificeerde steekproef voor het jaar 2019.

```{r leaflet-map, out.width="100%", fig.cap="(ref:leaflet-map)"}
benthos_afdw_zeeschelde_durme %>%
  filter(jaar == "2019") %>%
  mapview(zcol = c("survey"), burst = TRUE)
```

## Alternatieve berekening via post-stratificatie

```{r benthos-afdw-poststrat}
benthos_afdw_poststrat <- benthos_afdw_zeeschelde_durme %>%
  filter(tidaal != "subtidaal") %>%
  st_drop_geometry() %>%
  rename(ecotoop_werkelijk = ecotoop_werkelijk.benthos) %>%
  distinct(jaar, survey, KRWzone, SalZone,
           ecotoop_werkelijk,
           stratum_opp_m2) %>%
  ungroup()
```

```{r hg-spatial, message=FALSE}
fs::dir_create(find_root_file("src/rapport/brms_models",
                              criterion = is_git_root))
# multilevel regression + poststratification
benthos_afdw_zeeschelde_durme %>%
  filter(tidaal != "subtidaal",
         survey == "spatial") %>%
  rename(ecotoop_werkelijk = ecotoop_werkelijk.benthos) %>%
  st_drop_geometry() %>%
  brm(bf(
    tot_afdw ~
      jaar
    + (1 | jaar:ecotoop_werkelijk)
    + (1 | jaar:KRWzone)
    + (1 | jaar:ecotoop_werkelijk:KRWzone),
    hu ~
      jaar
    + (1 | jaar:ecotoop_werkelijk)
    + (1 | jaar:KRWzone)
    + (1 | jaar:ecotoop_werkelijk:KRWzone)
  ),
  family = hurdle_gamma(),
  data = .,
  silent = 2,
  cores = 4,
  control = list(adapt_delta = 0.95),
  backend = "cmdstanr",
  file = find_root_file("src/rapport/brms_models/hg_spatial",
                        criterion = is_git_root),
  file_refit = "on_change"
  ) -> hg_spatial
```

```{r hg-raai}
benthos_afdw_zeeschelde_durme %>%
  filter(tidaal != "subtidaal",
         survey == "raai") %>%
  rename(ecotoop_werkelijk = ecotoop_werkelijk.benthos) %>%
  st_drop_geometry() %>%
  brm(bf(
    tot_afdw ~
      jaar
    + (1 | jaar:ecotoop_werkelijk)
    + (1 | jaar:KRWzone)
    + (1 | jaar:ecotoop_werkelijk:KRWzone),
    hu ~
      jaar
    + (1 | jaar:ecotoop_werkelijk)
    + (1 | jaar:KRWzone)
    + (1 | jaar:ecotoop_werkelijk:KRWzone)
  ),
  family = hurdle_gamma(),
  data = .,
  silent = 2,
  cores = 4,
  control = list(adapt_delta = 0.95),
  backend = "cmdstanr",
  file = find_root_file("src/rapport/brms_models/hg_raai",
                        criterion = is_git_root),
  file_refit = "on_change"
  ) -> hg_raai
```

```{r hg-raaispatial}
benthos_afdw_zeeschelde_durme %>%
  filter(tidaal != "subtidaal") %>%
  rename(ecotoop_werkelijk = ecotoop_werkelijk.benthos) %>%
  st_drop_geometry() %>%
  brm(bf(
    tot_afdw ~
      jaar
    + survey
    + jaar:survey
    + (1 | survey:jaar:ecotoop_werkelijk)
    + (1 | survey:jaar:KRWzone)
    + (1 | survey:jaar:ecotoop_werkelijk:KRWzone),
    hu ~
      jaar
    + survey
    + jaar:survey
    + (1 | survey:jaar:ecotoop_werkelijk)
    + (1 | survey:jaar:KRWzone)
    + (1 | survey:jaar:ecotoop_werkelijk:KRWzone)
  ),
  family = hurdle_gamma(),
  data = .,
  silent = 2,
  cores = 4,
  control = list(adapt_delta = 0.95),
  backend = "cmdstanr",
  file = find_root_file("src/rapport/brms_models/hg_raaispatial",
                        criterion = is_git_root),
  file_refit = "on_change"
  ) -> hg_raaispatial
```

```{r hg-raaispatial-2}
benthos_afdw_zeeschelde_durme %>%
  filter(tidaal != "subtidaal") %>%
  rename(ecotoop_werkelijk = ecotoop_werkelijk.benthos) %>%
  st_drop_geometry() %>%
  brm(bf(
    tot_afdw ~
      jaar
    + (1 | jaar:ecotoop_werkelijk)
    + (1 | jaar:KRWzone)
    + (1 | jaar:ecotoop_werkelijk:KRWzone),
    hu ~
      jaar
    + (1 | jaar:ecotoop_werkelijk)
    + (1 | jaar:KRWzone)
    + (1 | jaar:ecotoop_werkelijk:KRWzone)
  ),
  family = hurdle_gamma(),
  data = .,
  silent = 2,
  cores = 4,
  control = list(adapt_delta = 0.95),
  backend = "cmdstanr",
  file = find_root_file("src/rapport/brms_models/hg_raaispatial_2",
                        criterion = is_git_root),
  file_refit = "on_change"
  ) -> hg_raaispatial_2
```

```{r hg-spatial-schattingen}
poststrat_spatial <- benthos_afdw_poststrat %>%
  filter(survey == "spatial")

hg_spatial %>%
  add_linpred_draws(newdata = poststrat_spatial) %>%
  mean_qi() %>%
  mutate(across(c(.linpred, .lower, .upper),
                ~exp(.) / opp_per_staal_m2,
                .names = "exp{.col}")) %>%
  group_by(jaar) %>%
  summarise(across(c(exp.linpred, exp.lower, exp.upper),
                   ~sum(. * stratum_opp_m2) / 1e6)) %>%
  kable(digits = 1)
```

```{r hg-spatial-schattingen-subtargets}
hg_spatial %>%
  add_linpred_draws(newdata = poststrat_spatial) %>%
  mean_qi() %>%
  mutate(across(c(.linpred, .lower, .upper),
                ~exp(.) / opp_per_staal_m2,
                .names = "exp{.col}")) %>%
  group_by(jaar, SalZone) %>%
  summarise(across(c(exp.linpred, exp.lower, exp.upper),
                   ~sum(. * stratum_opp_m2) / 1e6)) %>%
  kable(digits = 1)
```

```{r hg-raai-schattingen}
poststrat_raai <- benthos_afdw_poststrat %>%
  filter(survey == "raai")

hg_raai %>%
  add_linpred_draws(newdata = poststrat_raai) %>%
  mean_qi() %>%
  mutate(across(c(.linpred, .lower, .upper),
                ~exp(.) / opp_per_staal_m2,
                .names = "exp{.col}")) %>%
  group_by(jaar) %>%
  summarise(across(c(exp.linpred, exp.lower, exp.upper),
                   ~sum(. * stratum_opp_m2) / 1e6)) %>%
  kable(digits = 1)
```

```{r hg-raai-schattingen-subtargets}
hg_raai %>%
  add_linpred_draws(newdata = poststrat_raai) %>%
  mean_qi() %>%
  mutate(across(c(.linpred, .lower, .upper),
                ~exp(.) / opp_per_staal_m2,
                .names = "exp{.col}")) %>%
  group_by(jaar, SalZone) %>%
  summarise(across(c(exp.linpred, exp.lower, exp.upper),
                   ~sum(. * stratum_opp_m2) / 1e6)) %>%
  kable(digits = 1)
```

```{r hg-raaispatial-schattingen}
hg_raaispatial %>%
  add_linpred_draws(newdata = benthos_afdw_poststrat) %>%
  mean_qi() %>%
  mutate(across(c(.linpred, .lower, .upper),
                ~exp(.) / opp_per_staal_m2,
                .names = "exp{.col}")) %>%
  group_by(survey, jaar) %>%
  summarise(across(c(exp.linpred, exp.lower, exp.upper),
                   ~sum(. * stratum_opp_m2) / 1e6)) %>%
  kable(digits = 1)
```

```{r hg-raaispatial-schattingen-subtargets}
hg_raaispatial %>%
  add_linpred_draws(newdata = benthos_afdw_poststrat) %>%
  mean_qi() %>%
  mutate(across(c(.linpred, .lower, .upper),
                ~exp(.) / opp_per_staal_m2,
                .names = "exp{.col}")) %>%
  group_by(survey, jaar, SalZone) %>%
  summarise(across(c(exp.linpred, exp.lower, exp.upper),
                   ~sum(. * stratum_opp_m2) / 1e6)) %>%
  kable(digits = 1)
```

```{r hg-raaispatial-2-schattingen}
hg_raaispatial_2 %>%
  add_linpred_draws(newdata = benthos_afdw_poststrat %>%
                      select(-survey) %>%
                      distinct()) %>%
  mean_qi() %>%
  mutate(across(c(.linpred, .lower, .upper),
                ~exp(.) / opp_per_staal_m2,
                .names = "exp{.col}")) %>%
  group_by(jaar) %>%
  summarise(across(c(exp.linpred, exp.lower, exp.upper),
                   ~sum(. * stratum_opp_m2) / 1e6)) %>%
  kable(digits = 1)
```

```{r hg-raaispatial-2-schattingen-subtargets}
hg_raaispatial_2 %>%
  add_linpred_draws(newdata = benthos_afdw_poststrat %>%
                      select(-survey) %>%
                      distinct()) %>%
  mean_qi() %>%
  mutate(across(c(.linpred, .lower, .upper),
                ~exp(.) / opp_per_staal_m2,
                .names = "exp{.col}")) %>%
  group_by(jaar, SalZone) %>%
  summarise(across(c(exp.linpred, exp.lower, exp.upper),
                   ~sum(. * stratum_opp_m2) / 1e6)) %>%
  kable(digits = 1)
```

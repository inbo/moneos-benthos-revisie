---
bibliography: moneos.bib
---

# Resultaten

## Inschatting tonnage droge massa macrozo√∂benthos via gestratificeerde aselecte steekproef

```{r svytotal-jaar}
# data.frame maken met alle survey design variabele en responsvariabelen
benthos_design <- benthos_afdw_spatial %>%
  as_survey_design(strata = c(KRWzone, ecotoop_werkelijk.benthos),
                   weights = stratum_weight)

# https://cran.r-project.org/web/packages/srvyr/vignettes/srvyr-vs-survey.html
# Horvitz-Thompson type schatters
benthos_design %>%
  group_by(jaar) %>%
  summarize(
    n = n(),
    totopp_km2 = sum(unique(stratum_opp_m2)) / 1e6,
    mzb_tonnage = survey_total(
    x = tot_afdw / 1e6,
    na.rm = TRUE,
    vartype = "ci",
    level = 0.95)) %>%
  mutate(methode = "Horvitz-Thompson") -> svytotal_jaar
```

```{r svytotal-salzone}
# https://cran.r-project.org/web/packages/srvyr/vignettes/srvyr-vs-survey.html
# Horvitz-Thompson type schatters
benthos_design %>%
  group_by(jaar, SalZone) %>%
  summarize(
        n = n(),
        totopp_km2 = sum(unique(stratum_opp_m2)) / 1e6,
        mzb_tonnage = survey_total(
          x = tot_afdw / 1e6,
          na.rm = TRUE,
          vartype = "ci",
          level = 0.95)) %>%
  mutate(methode = "Horvitz-Thompson") -> svytotal_salzone
```

```{r svymle, eval=FALSE}
# ofwel droge stof via hurdle gamma distributie?
# cf examples in ?survey::svymle (voor censored lognormal)
# censored kan eventueel ook een optie zijn: alle nullen beschouwen als
# links-gecensureerde data met kleine cutoff
# zie ook ?survey::svysurvreg

# not working
# in terms of linear predictors (lp)
loglike_hurdle_gamma <- function(y, lp_shape, lp_rate, lp_hu) {
  hu <- plogis(lp_hu)
  shape <- exp(lp_shape)
  rate <- exp(lp_rate)
  ifelse(y == 0,
         dbinom(1, 1, hu, log = TRUE),
         dbinom(0, 1, hu, log = TRUE) +
           dgamma(y, shape = shape, rate = rate, log = TRUE)
  )
}

# derivatives with respect to hu, shape and rate

d_lp_shape <- function(y, lp_shape, lp_rate, lp_hu) {
  hu <- plogis(lp_hu)
  shape <- exp(lp_shape)
  rate <- exp(lp_rate)
  d_shape <- ifelse(
    y == 0,
    - (1 - y) / (1 - hu),
    y / hu +
      exp(-rate * y) * y^(shape - 1) * rate^shape / gamma(shape) *
      (log(rate) + log(y) - digamma(shape))
  )
  return(d_shape * shape)
}

d_lp_rate <- function(y, lp_shape, lp_rate, lp_hu) {
  hu <- plogis(lp_hu)
  shape <- exp(lp_shape)
  rate <- exp(lp_rate)
  d_rate <- ifelse(
    y == 0,
    - (1 - y) / (1 - hu),
    y / hu +
      y^(shape - 1) / gamma(shape) * exp(-rate * y) * rate^(shape - 1)
    * (shape - y * rate)
    )
  return(d_rate * rate)
}

d_lp_hu <- function(y, lp_shape, lp_rate, lp_hu) {
  hu <- plogis(lp_hu)
  d_hu <- y / hu - (1 - y) / (1 - hu)
  return(d_hu * (1 / hu + 1 / (1 - hu)) ^ (-1))
}

gradient_hurdle_gamma <- function(y, lp_shape, lp_rate, lp_hu) {
  return(
    cbind(
      d_lp_shape(y, lp_shape, lp_rate, lp_hu),
      d_lp_rate(y, lp_shape, lp_rate, lp_hu),
      d_lp_hu(y, lp_shape, lp_rate, lp_hu)
      )
    )
}

m <- svymle(
  loglike = loglike_hurdle_gamma,
  gradient = gradient_hurdle_gamma,
  design = benthos_design,
  method = "Nelder-Mead",
  formulas = list(~tot_afdw,
                  lp_shape = ~ 0 + jaar,
                  lp_rate = ~ 0 + jaar,
                  lp_hu = ~ 0 + jaar),
  start = list(c(0.5, 0),
               c(0.5, 0),
               c(0.1, 0)
  ),
  control = list(maxit = 10000),
  na.action = "na.omit"
)


summary(m)

# see also https://github.com/strengejacke/sjstats/blob/master/R/svyglmzip.R

# need predict method to obtain population total estimates, but no method for
# svymle


# from ?svymle The usual variance estimator for MLEs in a survey sample is a
# `sandwich' variance that requires the score vector and the information matrix.
# It requires only sampling assumptions to be valid (though some model
# assumptions are required for it to be useful).
# This is the stderr="robust" option, which is available only when the gradient
# argument was specified.
data.frame(est = coef(m), se = SE(m)) %>%
  rownames_to_column(var = "parameter") %>%
  separate(parameter, into = c("parameter", "jaar"), sep = ".jaar")

# combine with var-covar matrix to calculate CI on overall mean?
m$sandwich
all.equal(SE(m), sqrt(diag(m$sandwich)))
samples <- MASS::mvrnorm(n = 1e5, mu = coef(m), Sigma = m$sandwich)

mle_summary <- samples %>%
  as_tibble() %>%
  mutate(
    log_zero_part.2018 = log(1 - plogis(lp_hu.jaar2018)),
    log_gamma_part.2018 = log(exp(lp_shape.jaar2018) / exp(lp_rate.jaar2018)),
    sum_logparts.2018 = log_zero_part.2018 + log_gamma_part.2018,
    log_zero_part.2019 = log(1 - plogis(lp_hu.jaar2019)),
    log_gamma_part.2019 = log(exp(lp_shape.jaar2019) / exp(lp_rate.jaar2019)),
    sum_logparts.2019 = log_zero_part.2019 + log_gamma_part.2019
    ) %>%
  select(starts_with("sum")) %>%
  pivot_longer(cols = everything()) %>%
  separate(name, c("name", "jaar"), sep = "\\.") %>%
  group_by(jaar) %>%
  summarize(y = exp(median(value)) /
              opp_per_staal_m2,
            ymin = exp(quantile(value, 0.025)) /
              opp_per_staal_m2,
            ymax = exp(quantile(value, 0.975)) /
              opp_per_staal_m2,
            y_alternative = mean(exp(value) / opp_per_staal_m2))

# gram per m2
mle_summary

# vergelijk met:
benthos_design %>%
  group_by(jaar) %>%
  summarize(
    n = n(),
    mzb_gram_per_m2 = survey_mean(
    x = tot_afdw / opp_per_staal_m2,
    na.rm = TRUE,
    vartype = "ci",
    level = 0.95))
# er zit zeker nog iets fout
```

```{r replicate-weights}
# using replicate weights on a hurdle-gamma regression
benthos_design_repl <- as.svrepdesign(benthos_design)

hg_optim <- withReplicates(
  benthos_design_repl,
  quote(
    glmmTMB(tot_afdw  ~ 0 + jaar,
            family = ziGamma(link = "log"),
            ziformula = ~ 0 + jaar,
            dispformula = ~ 0 + jaar,
            data = model.frame(design),
            weights = .weights,
            se = TRUE,
            na.action = na.omit,
            control = glmmTMBControl(
              optimizer = optim,
              optArgs = list(method = "BFGS")
            ))$fit$par),
  return.replicates = TRUE
)

hg_optim_estimates <- hg_optim %>%
  as_tibble() %>%
  mutate(param = rep(c("conditional", "hurdle", "dispersion"), each = 2),
         jaar = rep(c("2018", "2019"), times = 3)) %>%
  pivot_wider(id_cols = c(jaar),
              names_from = c(param),
              values_from = c(theta, SE)) %>%
  mutate(overall_mean = (1 - plogis(theta_hurdle)) * exp(theta_conditional))

hg_optim_sigma <- attr(hg_optim$theta, which = "var")
hg_optim_mean <- hg_optim$theta

hg_samples <- MASS::mvrnorm(n = 1e5, mu = hg_optim_mean, Sigma = hg_optim_sigma)
colnames(hg_samples) <- paste0(colnames(hg_samples), c(".2018", ".2019"))

hg_summary <- hg_samples %>%
  as_tibble() %>%
  mutate(
    epred.2018 = (1 - plogis(betazi.2018)) * exp(beta.2018),
    epred.2019 = (1 - plogis(betazi.2019)) * exp(beta.2019),
    ) %>%
  select(starts_with("epred")) %>%
  pivot_longer(cols = everything()) %>%
  separate(name, c("name", "jaar"), sep = "\\.") %>%
  group_by(jaar) %>%
  mode_hdci(value)
# convert to tonnes
totopp <- sum(unique(benthos_design$variables$stratum_opp_m2))
n_samples <- benthos_design$variables %>%
  count(jaar)

hg_summary %>%
  mutate(across(where(is.double) & !.width,
         ~ .x / opp_per_staal_m2 * totopp / 1e6),
         totopp_km2 = totopp / 1e6, 
         methode = "hg_replicated") %>%
    inner_join(n_samples, by = "jaar") %>%
  rename(mzb_tonnage = value,
         mzb_tonnage_low = .lower,
         mzb_tonnage_upp = .upper) -> hg_replicated_jaar
```

```{r replicate-weights-salzone, warning=FALSE, message=FALSE}
hg_salzone <- withReplicates(
  design = benthos_design_repl,
  quote(glmmTMB(tot_afdw  ~ 0 + jaar:SalZone,
            family = ziGamma(link = "log"),
            ziformula = ~ 0 + jaar:SalZone,
            dispformula = ~ 0 + jaar:SalZone,
            data = model.frame(design),
            weights = .weights,
            se = TRUE,
            na.action = na.omit
            ,
            control = glmmTMBControl(
              optimizer = optim,
              optArgs = list(method = "BFGS", maxit = 20000)
            )
        )$fit$par
      ),
  return.replicates = TRUE
)
#BFGS did not converge... nor did default algorithm. Really a problem or false?

hg_salzone_sigma <- attr(hg_salzone$theta, which = "var")
hg_salzone_mean <- hg_salzone$theta


hg_salzone_samples <- MASS::mvrnorm(n = 1e5,
                                    mu = hg_salzone_mean,
                                    Sigma = hg_salzone_sigma)
colnames(hg_salzone_samples) <- paste0(
  colnames(hg_salzone_samples),
  paste0(
    c("_2018_", "_2019_"),
    rep(make.names(unique(benthos_design$variables$SalZone)), each = 2)))

hg_salzone_samples <- hg_salzone_samples %>%
  as_tibble() %>%
  mutate(sample = row_number()) %>%
  pivot_longer(-sample) %>%
  separate(name, c("par", "jaar", "SalZone"), sep = "_")

hg_salzone_summary <- hg_salzone_samples %>%
  pivot_wider(names_from = par, values_from = value) %>%
  mutate(
    epred = (1 - plogis(betazi)) * exp(beta)) %>%
  group_by(jaar, SalZone) %>%
  mode_hdci(epred)

# convert to tonnes
jointable_salzone <- benthos_design_repl$variables %>%
  group_by(jaar, SalZone) %>%
  summarize(n = n(),
            totopp = sum(unique(stratum_opp_m2)))

hg_salzone_summary %>%
  mutate(SalZone = str_replace_all(SalZone, "\\.", " ")) %>%
  inner_join(jointable_salzone, by = c("jaar", "SalZone")) %>%
  mutate(across(where(is.double) & !.width & !totopp,
         ~ .x / opp_per_staal_m2 * totopp / 1e6),
         methode = "hg_replicated",
         totopp_km2 = totopp / 1e6) %>%
  select(-totopp) %>%
  rename(mzb_tonnage = epred,
         mzb_tonnage_low = .lower,
         mzb_tonnage_upp = .upper) -> hg_replicated_salzone
```

```{r eval=FALSE}
for (i in 1:194) {
  convergence <- glmmTMB(tot_afdw / opp_per_staal_m2 ~ 0 + jaar:SalZone,
            family = ziGamma(link = "log"),
            ziformula = ~ 0 + jaar:SalZone,
            dispformula = ~ 0 + jaar:SalZone,
            data = model.frame(benthos_design_repl),
            weights = weights(benthos_design_repl)[, i],
            se = TRUE,
            na.action = na.omit,
            control = glmmTMBControl(
              optimizer = optim,
              optArgs = list(method = "BFGS", maxit = 20000)
            ))
  cat(ifelse(convergence$fit$convergence > 0, i, "-"))
}

hg_summary

# vergelijk met:
bd_vergelijk <- benthos_design %>%
  group_by(jaar) %>%
  summarize(
    n = n(),
    mzb_gram_per_m2 = survey_mean(
    x = tot_afdw / opp_per_staal_m2,
    na.rm = TRUE,
    vartype = "ci",
    level = 0.95))

bd_vergelijk

all.equal(hg_summary$y,
          bd_vergelijk$mzb_gram_per_m2)

# lijkt er al beter op
# maar er is nog een klein verschil,
# dat er bijna niet was via rechtstreekse berekening
all.equal(
  hg_optim_estimates$overall_mean,
  bd_vergelijk$mzb_gram_per_m2)
```

```{r mrp-benthos-afdw-poststrat}
stratum_n <- benthos_afdw_zeeschelde_durme_rupel %>%
  st_drop_geometry() %>%
  filter(!str_detect(ecotoop_werkelijk.benthos, "subtidaal")) %>%
  count(jaar, survey,
        ecotoop_werkelijk = ecotoop_werkelijk.benthos,
        KRWzone, SalZone)

ecotoop %>%
  st_cast("POLYGON") %>%
  select(-Shape_Length, -Shape_Area, -Ecotoop) %>%
  filter(!is.na(NrRandomPunten),
         !str_detect(ecotoop_werkelijk, "subtidaal"),
         Naam %in% c("Zeeschelde", "Durme", "Rupel")) %>%
  mutate(opp_polygoon_m2 = as.numeric(st_area(.))) %>%
  st_drop_geometry() %>%
  group_by(SalZone, KRWzone, ecotoop_werkelijk) %>%
  summarise(stratum_opp_m2 = sum(opp_polygoon_m2),
            .groups = "drop") %>%
  droplevels() %>%
  expand_grid(survey = c("raai", "spatial"),
              jaar = factor(c("2018", "2019"))) %>%
  left_join(
    stratum_n,
    by = c("SalZone", "KRWzone", "survey", "jaar", "ecotoop_werkelijk")) %>%
  mutate(n = ifelse(is.na(n), 0, n)) -> benthos_afdw_poststrat
```

```{r mrp-spatial-model, message=FALSE}
fs::dir_create(find_root_file("src/rapport/brms_models",
                              criterion = is_git_root))
# multilevel regression + poststratification
benthos_afdw_spatial %>%
  rename(ecotoop_werkelijk = ecotoop_werkelijk.benthos) %>%
  st_drop_geometry() %>%
  brm(bf(
    tot_afdw ~
      jaar
    + (1 | jaar:ecotoop_werkelijk)
    + (1 | jaar:KRWzone)
    + (1 | jaar:ecotoop_werkelijk:KRWzone),
    hu ~
      jaar
    + (1 | jaar:ecotoop_werkelijk)
    + (1 | jaar:KRWzone)
    + (1 | jaar:ecotoop_werkelijk:KRWzone)
    ),
  family = hurdle_gamma(),
  data = .,
  silent = 2,
  cores = 4,
  control = list(adapt_delta = 0.95),
  backend = "cmdstanr",
  file = find_root_file("src/rapport/brms_models/mrp_spatial",
                        criterion = is_git_root),
  file_refit = "on_change"
  ) -> mrp_spatial
```

```{r mrp-spatial-jaar}
poststrat_spatial <- benthos_afdw_poststrat %>%
  filter(survey == "spatial")

mrp_spatial %>%
  add_epred_draws(newdata = poststrat_spatial) %>%
  # omzetting naar ton per stratum per jaar
  mutate(.epred = .epred / opp_per_staal_m2 * stratum_opp_m2 / 1e6) %>%
  # sommering naar ton voor gewenste groepering in elk jaar
  group_by(jaar, .draw) %>%
  summarise(.epred = sum(.epred),
            .groups = "drop_last") %>%
  # berekening modus en interval
  group_by(jaar) %>%
  mode_hdci(.epred) %>%
  rename(mzb_tonnage = .epred,
         mzb_tonnage_low = .lower,
         mzb_tonnage_upp = .upper) %>%
  inner_join(poststrat_spatial %>%
               group_by(jaar) %>%
               summarize(n = sum(n),
                         totopp_km2 = sum(stratum_opp_m2) / 1e6)
             ) %>%
  mutate(methode = "MRP") -> mrp_spatial_jaar
```

```{r eval=FALSE}
mrp_spatial %>%
  add_epred_draws(newdata = poststrat_spatial) %>%
  mutate(.epred = .epred / opp_per_staal_m2 * stratum_opp_m2 / 1e6) %>%
  # sommering naar ton voor gewenste groepering in elk jaar
  group_by(jaar, .draw) %>%
  summarise(.epred = sum(.epred),
            totopp_km2 = sum(stratum_opp_m2) / 1e6,
            .groups = "drop_last") %>%
  ggplot(aes(x = .epred, y = jaar)) +
  stat_halfeye(point_interval = mode_hdci, .width = c(.66, .95))

mrp_spatial %>%
  add_epred_draws(newdata = poststrat_spatial) %>%
  mutate(.epred = .epred / opp_per_staal_m2 * stratum_opp_m2 / 1e6) %>%
  # sommering naar ton voor gewenste groepering in elk jaar
  group_by(jaar, .draw) %>%
  summarise(.epred = sum(.epred),
            totopp_km2 = sum(stratum_opp_m2) / 1e6,
            .groups = "drop_last") %>%
  ggplot(aes(x = .epred, y = jaar)) +
  stat_halfeye(point_interval = median_qi, .width = c(.66, .95))
```

```{r mrp-spatial-salzone}
mrp_spatial %>%
  add_epred_draws(newdata = poststrat_spatial) %>%
  # omzetting naar ton per stratum per jaar
  mutate(.epred = .epred / opp_per_staal_m2 * stratum_opp_m2 / 1e6) %>%
  # sommering naar ton voor gewenste groepering in elk jaar
  group_by(jaar, SalZone, .draw) %>%
  summarise(.epred = sum(.epred),
            .groups = "drop_last") %>%
  # berekening modus en interval
  group_by(jaar, SalZone) %>%
  mode_hdci(.epred) %>%
  rename(mzb_tonnage = .epred,
         mzb_tonnage_low = .lower,
         mzb_tonnage_upp = .upper) %>%
  inner_join(poststrat_spatial %>%
               group_by(jaar, SalZone) %>%
               summarize(n = sum(n),
                         totopp_km2 = sum(stratum_opp_m2) / 1e6)
             ) %>%
  mutate(methode = "MRP") -> mrp_spatial_salzone
```

(ref:schattingen-overzichtstabel) Schatting van tonnages biomassa MZB volgens verschillende methodes in de intertidale zone van de Zeeschelde en Durme opgesplitst per jaar.

```{r schattingen-overzichtstabel}
bind_rows(svytotal_jaar, hg_replicated_jaar, mrp_spatial_jaar) %>%
  select(jaar, methode, n, totopp_km2, starts_with("mzb")) %>%
  arrange(desc(methode), jaar) %>%
  gt(caption = "(ref:schattingen-overzichtstabel)") %>%
  fmt_number(columns = where(is.double), decimals = 1)
```

(ref:schattingen-overzichtstabel-salzone) Schatting van tonnages biomassa MZB volgens verschillende methodes in de intertidale zone van de Zeeschelde en Durme opgesplitst per jaar en saliniteitszone.

```{r schattingen-overzichtstabel-salzone}
bind_rows(svytotal_salzone, hg_replicated_salzone, mrp_spatial_salzone) %>%
  select(jaar, SalZone, methode, n, totopp_km2, starts_with("mzb")) %>%
  arrange(desc(methode), jaar, SalZone) %>%
  group_by(methode, jaar) %>%
  gt(caption = "(ref:schattingen-overzichtstabel-salzone)") %>%
  fmt_number(columns = where(is.double), decimals = 1)
```

```{r eval=FALSE}
benthos_afdw_zeeschelde_durme_rupel %>%
  filter(tidaal == "subtidaal",
         Z > 0) %>%
  st_drop_geometry() %>%
  select(jaar, staal, ecotoop_werkelijk.benthos, KRWzone, Z) %>%
  gt()
```

## Inschatting aan de hand van enkel raaigegevens

In eerste stap veronderstellen we foutief dat de raaigegevens komen van een gestratificeerde aselecte steekproef.

```{r svytotal-raai-jaar}
# data.frame maken met alle survey design variabele en responsvariabelen
benthos_raai_design <- benthos_afdw_raai %>%
  as_survey_design(strata = c(KRWzone, ecotoop_werkelijk.benthos),
                   weights = stratum_weight)


benthos_raai_design %>%
  group_by(jaar) %>%
  summarise(
    n_raaien = n_distinct(staalcode),
    n = n(),
    totopp_km2 = sum(unique(stratum_opp_m2)) / 1e6,
    mzb_tonnage = survey_total(
      x = tot_afdw / 1e6,
      na.rm = TRUE,
      vartype = "ci",
      level = 0.95)) %>%
  mutate(methode = "Horvitz-Thompson") -> svytotal_raai_jaar
```

```{r svytotal-raai-salzone}
benthos_raai_design %>%
  group_by(jaar, SalZone) %>%
  summarise(
    n_raaien = n_distinct(staalcode),
    n = n(),
    totopp_km2 = sum(unique(stratum_opp_m2)) / 1e6,
    mzb_tonnage = survey_total(
      x = tot_afdw / 1e6,
      na.rm = TRUE,
      vartype = "ci",
      level = 0.95)) %>%
  mutate(methode = "Horvitz-Thompson") -> svytotal_raai_salzone
```

```{r mrp-raai-model}
benthos_afdw_raai %>%
  rename(ecotoop_werkelijk = ecotoop_werkelijk.benthos) %>%
  st_drop_geometry() %>%
  brm(bf(
    tot_afdw ~
      jaar
    + (1 | jaar:ecotoop_werkelijk)
    + (1 | jaar:KRWzone)
    + (1 | jaar:ecotoop_werkelijk:KRWzone),
    hu ~
      jaar
    + (1 | jaar:ecotoop_werkelijk)
    + (1 | jaar:KRWzone)
    + (1 | jaar:ecotoop_werkelijk:KRWzone)
  ),
  family = hurdle_gamma(),
  data = .,
  silent = 2,
  cores = 4,
  control = list(adapt_delta = 0.95),
  backend = "cmdstanr",
  file = find_root_file("src/rapport/brms_models/mrp_raai",
                        criterion = is_git_root),
  file_refit = "on_change"
  ) -> mrp_raai
```

Poststratificatie schattingen voor raaien:

1.  ofwel poststrata waarin geen raaien verwijderen = veranderen van de doelpopulatie

2.  ofwel poststrata behouden en het model predicties laten doen voor poststrata zonder data

    -   in dat geval zullen de geschatte "gemiddelde" biomassa ongeveer gelijk blijven
    -   maar interval zal breder zijn

Voor de MRP analyse op basis van enkel de raaigegevens, zaten in de posterior samples extreem hoge waarden voor de geschatte biomassa.
Om stabiele schattingen te krijgen werden daarom de 0.1% hoogste waarden verwijderd alvorens berekening van de modus en het interval.

```{r mrp-raai-jaar}
poststrat_raai <- benthos_afdw_poststrat %>%
  filter(survey == "raai")

mrp_raai %>%
  add_epred_draws(newdata = poststrat_raai,
                  allow_new_levels = TRUE) %>%
  # omzetting naar ton per stratum per jaar
  mutate(.epred = .epred / opp_per_staal_m2 * stratum_opp_m2 / 1e6) %>%
  # sommering naar ton voor gewenste groepering in elk jaar
  group_by(jaar, .draw) %>%
  summarise(.epred = sum(.epred),
            .groups = "drop_last") %>%
  # berekening modus en interval
  group_by(jaar) %>%
  filter(.epred < quantile(.epred, 0.999)) %>%
  mode_hdci(.epred) %>%
  rename(mzb_tonnage = .epred,
         mzb_tonnage_low = .lower,
         mzb_tonnage_upp = .upper) %>%
  inner_join(poststrat_raai %>%
               group_by(jaar) %>%
               summarize(n = sum(n),
                         totopp_km2 = sum(stratum_opp_m2) / 1e6)
             ) %>%
  mutate(methode = "MRP") -> mrp_raai_jaar
```

```{r mrp-raai-salzone}
mrp_raai %>%
  add_epred_draws(newdata = poststrat_raai,
                  allow_new_levels = TRUE) %>%
  # omzetting naar ton per stratum per jaar
  mutate(.epred = .epred / opp_per_staal_m2 * stratum_opp_m2 / 1e6) %>%
  # sommering naar ton voor gewenste groepering in elk jaar
  group_by(jaar, SalZone, .draw) %>%
  summarise(.epred = sum(.epred),
            .groups = "drop_last") %>%
  # berekening modus en interval
  group_by(jaar, SalZone) %>%
  filter(.epred < quantile(.epred, 0.999)) %>%
  mode_hdci(.epred) %>%
  rename(mzb_tonnage = .epred,
         mzb_tonnage_low = .lower,
         mzb_tonnage_upp = .upper) %>%
  inner_join(poststrat_raai %>%
               group_by(jaar, SalZone) %>%
               summarize(n = sum(n),
                         totopp_km2 = sum(stratum_opp_m2) / 1e6)
             ) %>%
  mutate(methode = "MRP") -> mrp_raai_salzone
```

(ref:schattingen-raai-overzichtstabel) Schatting van tonnages biomassa MZB volgens verschillende methodes in de intertidale zone van de Zeeschelde en Durme opgesplitst per jaar.

```{r schattingen-raai-overzichtstabel}
bind_rows(svytotal_raai_jaar, mrp_raai_jaar) %>%
  select(jaar, methode, n_raaien, n, totopp_km2, starts_with("mzb")) %>%
  arrange(desc(methode), jaar) %>%
  gt(caption = "(ref:schattingen-raai-overzichtstabel)") %>%
  fmt_number(columns = where(is.double), decimals = 1)
```

(ref:schattingen-raai-overzichtstabel-salzone) Schatting van tonnages biomassa MZB volgens verschillende methodes in de intertidale zone van de Zeeschelde en Durme opgesplitst per jaar en saliniteitszone.

```{r schattingen-raai-overzichtstabel-salzone}
bind_rows(svytotal_raai_salzone, mrp_raai_salzone) %>%
  select(jaar, SalZone, methode, n_raaien, n, totopp_km2, starts_with("mzb")) %>%
  arrange(desc(methode), jaar, SalZone) %>%
  group_by(methode, jaar) %>%
  gt(caption = "(ref:schattingen-raai-overzichtstabel-salzone)") %>%
  fmt_number(columns = where(is.double), decimals = 1)
```

Wellicht sterk vertekende schattingen (overschatting vermits vooral in beste gebieden).
Bovendien bekomen we bredere betrouwbaarheidsintervallen ondanks een hoger aantal locaties die via raaien bemonsterd worden in het intertidaal (150 versus 100-tal).

De berekeningen voor de raaien op basis van Horvitz-Thompson schatters zijn fout om minstens twee redenen: (1) we hielden geen rekening met de raaien, en (2) we gebruiken design-based inferentie terwijl het geen probabilistische steekproef betreft.

## Vergelijking spatial en raai surveys

```{r mrp-raaispatial}
benthos_afdw_zeeschelde_durme_rupel %>%
  filter(tidaal != "subtidaal") %>%
  rename(ecotoop_werkelijk = ecotoop_werkelijk.benthos) %>%
  st_drop_geometry() %>%
  brm(bf(
    tot_afdw ~
      jaar
    + survey
    + jaar:survey
    + (1 | survey:jaar:ecotoop_werkelijk)
    + (1 | survey:jaar:KRWzone)
    + (1 | survey:jaar:ecotoop_werkelijk:KRWzone),
    hu ~
      jaar
    + survey
    + jaar:survey
    + (1 | survey:jaar:ecotoop_werkelijk)
    + (1 | survey:jaar:KRWzone)
    + (1 | survey:jaar:ecotoop_werkelijk:KRWzone)
  ),
  family = hurdle_gamma(),
  data = .,
  silent = 2,
  cores = 4,
  control = list(adapt_delta = 0.95),
  backend = "cmdstanr",
  file = find_root_file("src/rapport/brms_models/mrp_raaispatial",
                        criterion = is_git_root),
  file_refit = "on_change"
  ) -> mrp_raaispatial
```

```{r mrp-raaispatial-2}
benthos_afdw_zeeschelde_durme_rupel %>%
  filter(tidaal != "subtidaal") %>%
  rename(ecotoop_werkelijk = ecotoop_werkelijk.benthos) %>%
  st_drop_geometry() %>%
  brm(bf(
    tot_afdw ~
      jaar
    + (1 | jaar:ecotoop_werkelijk)
    + (1 | jaar:KRWzone)
    + (1 | jaar:ecotoop_werkelijk:KRWzone),
    hu ~
      jaar
    + (1 | jaar:ecotoop_werkelijk)
    + (1 | jaar:KRWzone)
    + (1 | jaar:ecotoop_werkelijk:KRWzone)
  ),
  family = hurdle_gamma(),
  data = .,
  silent = 2,
  cores = 4,
  control = list(adapt_delta = 0.95),
  backend = "cmdstanr",
  file = find_root_file("src/rapport/brms_models/mrp_raaispatial_2",
                        criterion = is_git_root),
  file_refit = "on_change"
  ) -> mrp_raaispatial_2
```

```{r mrp-raaispatial-jaar}
mrp_raaispatial %>%
  add_epred_draws(newdata = benthos_afdw_poststrat,
                  allow_new_levels = TRUE) %>%
  # omzetting naar ton per stratum per jaar
  mutate(.epred = .epred / opp_per_staal_m2 * stratum_opp_m2 / 1e6) %>%
  # sommering naar ton voor gewenste groepering in elk jaar
  group_by(survey, jaar, .draw) %>%
  summarise(.epred = sum(.epred),
            .groups = "drop_last") %>%
  # berekening modus en interval
  group_by(survey, jaar) %>%
  mode_hdci(.epred) %>%
  rename(mzb_tonnage = .epred,
         mzb_tonnage_low = .lower,
         mzb_tonnage_upp = .upper) %>%
  inner_join(benthos_afdw_poststrat %>%
               group_by(survey, jaar) %>%
               summarize(n = sum(n),
                         totopp_km2 = sum(stratum_opp_m2) / 1e6)
             ) %>%
  mutate(methode = "MRP") -> mrp_raaispatial_jaar
```

```{r mrp-raaispatial-salzone}
mrp_raaispatial %>%
  add_epred_draws(newdata = benthos_afdw_poststrat,
                  allow_new_levels = TRUE) %>%
  # omzetting naar ton per stratum per jaar
  mutate(.epred = .epred / opp_per_staal_m2 * stratum_opp_m2 / 1e6) %>%
  # sommering naar ton voor gewenste groepering in elk jaar
  group_by(survey, jaar, SalZone, .draw) %>%
  summarise(.epred = sum(.epred),
            .groups = "drop_last") %>%
  # berekening modus en interval
  group_by(survey, jaar, SalZone) %>%
  mode_hdci(.epred) %>%
  rename(mzb_tonnage = .epred,
         mzb_tonnage_low = .lower,
         mzb_tonnage_upp = .upper) %>%
  inner_join(benthos_afdw_poststrat %>%
               group_by(survey, jaar, SalZone) %>%
               summarize(n = sum(n),
                         totopp_km2 = sum(stratum_opp_m2) / 1e6)
             ) %>%
  mutate(methode = "MRP") -> mrp_raaispatial_salzone
```

```{r mrp-raaispatial-2-jaar}
mrp_raaispatial_2 %>%
  add_epred_draws(newdata = benthos_afdw_poststrat,
                  allow_new_levels = TRUE) %>%
  # omzetting naar ton per stratum per jaar
  mutate(.epred = .epred / opp_per_staal_m2 * stratum_opp_m2 / 1e6) %>%
  # sommering naar ton voor gewenste groepering in elk jaar
  group_by(jaar, .draw) %>%
  summarise(.epred = sum(.epred),
            .groups = "drop_last") %>%
  # berekening modus en interval
  group_by(jaar) %>%
  mode_hdci(.epred) %>%
  rename(mzb_tonnage = .epred,
         mzb_tonnage_low = .lower,
         mzb_tonnage_upp = .upper) %>%
  inner_join(benthos_afdw_poststrat %>%
               group_by(jaar) %>%
               summarize(n = sum(n),
                         totopp_km2 = sum(stratum_opp_m2) / 1e6)
             ) %>%
  mutate(methode = "MRP") -> mrp_raaispatial2_jaar
```

```{r mrp-raaispatial-2-salzone}
mrp_raaispatial_2 %>%
  add_epred_draws(newdata = benthos_afdw_poststrat,
                  allow_new_levels = TRUE) %>%
  # omzetting naar ton per stratum per jaar
  mutate(.epred = .epred / opp_per_staal_m2 * stratum_opp_m2 / 1e6) %>%
  # sommering naar ton voor gewenste groepering in elk jaar
  group_by(jaar, SalZone, .draw) %>%
  summarise(.epred = sum(.epred),
            .groups = "drop_last") %>%
  # berekening modus en interval
  group_by(jaar, SalZone) %>%
  mode_hdci(.epred) %>%
  rename(mzb_tonnage = .epred,
         mzb_tonnage_low = .lower,
         mzb_tonnage_upp = .upper) %>%
  inner_join(benthos_afdw_poststrat %>%
               group_by(jaar, SalZone) %>%
               summarize(n = sum(n),
                         totopp_km2 = sum(stratum_opp_m2) / 1e6)
             ) %>%
  mutate(methode = "MRP") -> mrp_raaispatial2_salzone
```

```{r}
bind_rows(mrp_raaispatial_jaar,
          mrp_raaispatial2_jaar) %>%
  gt(caption = "(ref:)") %>%
  fmt_number(columns = where(is.double), decimals = 1)
```

```{r}
bind_rows(mrp_raaispatial_salzone,
          mrp_raaispatial2_salzone) %>%
  gt(caption = "(ref:)") %>%
  fmt_number(columns = where(is.double), decimals = 1)
```

## Varia

Er lijkt een piek te zijn in de biomassa bij gemiddelde hoogte in het intertidaal.
Dit is zowel in de spatial survey als de raai-survey te zien (Figuur \@ref(fig:biomassa-hoogte)).
In principe kan dan de hoogtevariabele (die bij benadering overal gekend is via DTM beeld) gebruikt worden om de schattingen te verbeteren via design-based regressieschatters (**kan** leiden tot iets smallere betrouwbaarheidsintervallen).

(ref:biomassa-hoogte) Biomassa in functie van hoogteligging in het intertidaal voor beide survey-types.

```{r biomassa-hoogte, fig.cap="(ref:biomassa-hoogte)"}
benthos_afdw_zeeschelde_durme_rupel %>%
  filter(tidaal == "intertidaal") %>%
  ggplot(aes(x = Z, y = tot_afdw, colour = jaar)) +
  geom_point() +
  geom_smooth() +
  scale_y_sqrt() +
  facet_wrap(tidaal~survey, scales = "free") +
  labs(x = "Hoogte (m)",
       y = "Biomassa (g)")
```
